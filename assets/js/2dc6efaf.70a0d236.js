"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[6353],{21533:function(e,t,a){a.r(t),a.d(t,{assets:function(){return m},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return c}});var n=a(87462),r=a(63366),i=(a(67294),a(3905)),s=["components"],o={description:"Markers is a tool to efficiently estimate the approval weight of a message and that reduces the portion of the Tangle that needs to be traversed, and which finally results in the grade of finality.",image:"/img/protocol_specification/example_1.png",keywords:["approval weight","marker","message","sequence","future marker","new marker","part marker","past cone"]},l="Markers",p={unversionedId:"protocol_specification/components/markers",id:"protocol_specification/components/markers",title:"Markers",description:"Markers is a tool to efficiently estimate the approval weight of a message and that reduces the portion of the Tangle that needs to be traversed, and which finally results in the grade of finality.",source:"@site/content/build/goshimmer/develop/documentation/docs/protocol_specification/components/markers.md",sourceDirName:"protocol_specification/components",slug:"/protocol_specification/components/markers",permalink:"/goshimmer/protocol_specification/components/markers",draft:!1,editUrl:"https://github.com/iotaledger/goshimmer/edit/develop/documentation/content/build/goshimmer/develop/documentation/docs/protocol_specification/components/markers.md",tags:[],version:"current",frontMatter:{description:"Markers is a tool to efficiently estimate the approval weight of a message and that reduces the portion of the Tangle that needs to be traversed, and which finally results in the grade of finality.",image:"/img/protocol_specification/example_1.png",keywords:["approval weight","marker","message","sequence","future marker","new marker","part marker","past cone"]},sidebar:"docs",previous:{title:"UTXO Output Types",permalink:"/goshimmer/protocol_specification/components/advanced_outputs"},next:{title:"Glossary",permalink:"/goshimmer/protocol_specification/glossary"}},m={},c=[{value:"Summary",id:"summary",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Definitions",id:"definitions",level:2},{value:"Design",id:"design",level:2},{value:"Sequences",id:"sequences",level:3},{value:"Sequence Graph",id:"sequence-graph",level:3},{value:"Usage",id:"usage",level:2},{value:"Markers Application: Approval Weight Estimation",id:"markers-application-approval-weight-estimation",level:3},{value:"Branch Mapping",id:"branch-mapping",level:3}],u={toc:c};function h(e){var t=e.components,a=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"markers"},"Markers"),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("p",null,"Operations that involve traversing the Tangle are very performance intensive and, thus, we need to minimize the amount of traversing to keep algorithms fast. Markers are a tool to infer structural knowledge about the Tangle without actually traversing it."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"Note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},(0,i.kt)("strong",{parentName:"p"},"Markers")," are not a core module of the Coordicide project."))),(0,i.kt)("h2",{id:"motivation"},"Motivation"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Markers")," are a tool to infer knowledge about the structure of the Tangle, therefore, we use them to keep algorithms fast. Specifically, markers are used for:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"past/future cone membership;"),(0,i.kt)("li",{parentName:"ul"},"approximate approval weight of any message;"),(0,i.kt)("li",{parentName:"ul"},"tagging sections of the Tangle (e.g., branches) without having to traverse each message individually.")),(0,i.kt)("h2",{id:"definitions"},"Definitions"),(0,i.kt)("p",null,"Let's define the terms related to markers:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Sequence:")," A sequence is a chain of markers where each progressing marker contains all preceding markers of the sequence in its past cone."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Sequence Identifier (",(0,i.kt)("inlineCode",{parentName:"strong"},"SID"),"):")," A Sequence Identifier is the unique identifier of a Sequence."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Marker Index (",(0,i.kt)("inlineCode",{parentName:"strong"},"MI"),"):")," A Marker Index is the marker rank in the marker DAG. Throughout the code the marker rank will be called index."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"marker:")," A marker is a pair of numbers: ",(0,i.kt)("inlineCode",{parentName:"li"},"SID")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"MI")," associated to a given message. Markers carrying the same ",(0,i.kt)("inlineCode",{parentName:"li"},"SID")," belong to the same Sequence."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"future marker (",(0,i.kt)("inlineCode",{parentName:"strong"},"FM"),"):")," A future marker of a message is the first marker in its future cone from different sequences."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"past marker (",(0,i.kt)("inlineCode",{parentName:"strong"},"PM"),"):")," A past marker of a message is a marker in its past cone (can be multiple markers of distinct sequences). For a given sequence it is set to the newest past marker of its parents, that is the one that has the largest ",(0,i.kt)("inlineCode",{parentName:"li"},"MI"),". The past marker of a marker is set to itself.")),(0,i.kt)("h2",{id:"design"},"Design"),(0,i.kt)("p",null,"On a high level, markers provide structural knowledge of the Tangle and each individual message without the need to traverse (aka walking the Tangle). Markers are a form of meta-information (for each message) that each node locally creates when processing messages. They can be seen as specific, uniquely tainted messages that, taken together, again build a DAG within the Tangle. We can then utilize this marker DAG to determine structural details."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/3x7H68t.png",alt:null})),(0,i.kt)("p",null,"The above example shows a Tangle with the red messages being markers in the same sequence (more details on sequences later). A marker is uniquely identified by ",(0,i.kt)("inlineCode",{parentName:"p"},"sequenceID,index"),', where the index is ever-increasing. Any message can be "selected" as a marker if it fulfills a certain set of rules:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"every n-th message (in the example, each message is tried to be set as a marker)"),(0,i.kt)("li",{parentName:"ul"},"latest marker of sequence is in its past cone.")),(0,i.kt)("p",null,"The markers build a chain/DAG and because of the rules it becomes clear that ",(0,i.kt)("inlineCode",{parentName:"p"},"marker 0,1")," is in the past cone of ",(0,i.kt)("inlineCode",{parentName:"p"},"marker 0,5"),". Since markers represent meta-information for the underlying messages and each message keeps the latest marker in its past cone as ",(0,i.kt)("em",{parentName:"p"},"structural information"),", we can infer that ",(0,i.kt)("inlineCode",{parentName:"p"},"message B")," (",(0,i.kt)("inlineCode",{parentName:"p"},"FM 0,2"),") is in the past cone of ",(0,i.kt)("inlineCode",{parentName:"p"},"message I")," (",(0,i.kt)("inlineCode",{parentName:"p"},"PM 0,3"),")  Similarly, it is evident that ",(0,i.kt)("inlineCode",{parentName:"p"},"message D")," is in the past cone of ",(0,i.kt)("inlineCode",{parentName:"p"},"message J"),"."),(0,i.kt)("h3",{id:"sequences"},"Sequences"),(0,i.kt)("p",null,"A sequence is a chain of markers where each progressing marker contains all preceding markers of the sequence in its past cone. However, this very definition entails a problem: what if there are certain parts of the Tangle that are disparate to each other. Assuming only a single sequence, this would mean that a certain part of the Tangle can't get any markers. In turn, certain operations within this part of the Tangle would involve walking."),(0,i.kt)("p",null,"For this reason, we keep track of the ",(0,i.kt)("em",{parentName:"p"},"marker distance"),", which signals the distance of messages in the Tangle in a certain past cone where no marker could be assigned. If this distance gets too big, a new sequence is created as is shown in the example below (marker distance to spawn a new sequence = 3)."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/Q44XZgk.png",alt:null})),(0,i.kt)("p",null,"The example above shows a side chain starting from ",(0,i.kt)("inlineCode",{parentName:"p"},"message L")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"message P"),' where it merges back with the "main Tangle". There can be no new marker assigned as none of the ',(0,i.kt)("inlineCode",{parentName:"p"},"messages L-O")," have the latest marker of ",(0,i.kt)("inlineCode",{parentName:"p"},"sequence 0")," in their past cone. The marker distance grows and eventually a marker is created at ",(0,i.kt)("inlineCode",{parentName:"p"},"message N"),". Following, a marker can be assigned to ",(0,i.kt)("inlineCode",{parentName:"p"},"message O")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"message P"),". The latter is special because it combines two sequences. This is to be expected as disparate parts of the Tangle should be merged eventually. In case a message has markers from multiple sequences in its past cones the following rules apply:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Assign a marker in the highest sequence if possible. If not possible, try to assign a marker in the next lower sequence."),(0,i.kt)("li",{parentName:"ul"},"The index is ",(0,i.kt)("inlineCode",{parentName:"li"},"max(marker1.Index,marker2.Index,...)"))),(0,i.kt)("p",null,"With these rules in mind, it becomes clear why ",(0,i.kt)("inlineCode",{parentName:"p"},"message P")," has the ",(0,i.kt)("inlineCode",{parentName:"p"},"marker 1,6")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"message R")," has ",(0,i.kt)("inlineCode",{parentName:"p"},"marker 1,7"),". In case of ",(0,i.kt)("inlineCode",{parentName:"p"},"message Q"),", no marker can be assigned to ",(0,i.kt)("inlineCode",{parentName:"p"},"sequence 1"),", and, thus, a new marker in ",(0,i.kt)("inlineCode",{parentName:"p"},"sequence 0")," is created."),(0,i.kt)("p",null,"Always continuing the highest seqeuence should result in smaller sequences being discontinued once disparate parts of the Tangle merge and overall a relatively small number of sequences (optimally just one) is expected to be active at any given moment in time."),(0,i.kt)("h3",{id:"sequence-graph"},"Sequence Graph"),(0,i.kt)("p",null,"The information that markers yield about past and future cone is only valid for any given sequence individually. However, to relate markers of separate sequences, we need to track dependencies between sequences.\nTherefore, sequences build a graph between each other, where relationships between the sequences can be seen."),(0,i.kt)("p",null,"Each sequence keeps track of ",(0,i.kt)("strong",{parentName:"p"},"referenced sequences")," and ",(0,i.kt)("strong",{parentName:"p"},"referencing sequences")," at a specific marker index so that bidirectional traversing into the future and past are possible from a sequence is possible."),(0,i.kt)("p",null,"Specifically, in our example there are 3 bidirectional references between ",(0,i.kt)("inlineCode",{parentName:"p"},"sequence 0")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"sequence 1"),".\nSequence 0:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0,1"),"<->",(0,i.kt)("inlineCode",{parentName:"li"},"1,2")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0,5"),"<->",(0,i.kt)("inlineCode",{parentName:"li"},"1,6")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0,6"),"<->",(0,i.kt)("inlineCode",{parentName:"li"},"1,7"))),(0,i.kt)("p",null,"Sequence 1:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1,2"),"<->",(0,i.kt)("inlineCode",{parentName:"li"},"0,1")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1,6"),"<->",(0,i.kt)("inlineCode",{parentName:"li"},"0,5")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1,7"),"<->",(0,i.kt)("inlineCode",{parentName:"li"},"0,6"))),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/EhbJohc.png",alt:null})),(0,i.kt)("h2",{id:"usage"},"Usage"),(0,i.kt)("h3",{id:"markers-application-approval-weight-estimation"},"Markers Application: Approval Weight Estimation"),(0,i.kt)("p",null,"To approximate the approval weight of a message, we simply retrieve the approval weight of its ",(0,i.kt)("inlineCode",{parentName:"p"},"FM")," list. Since the message is in the past cone of its ",(0,i.kt)("inlineCode",{parentName:"p"},"FM"),"s, the approval weight and the finality will be at least the same as its ",(0,i.kt)("inlineCode",{parentName:"p"},"FM"),"s. This will of course be a lower bound (which is the \u201csafe\u201d bound), but if the markers are set frequently enough, it should be a good approximation.\nIn practice, we propagate the GoF finality to messages in a marker's past cone until we reach another marker."),(0,i.kt)("p",null,"For details of managing approval weight of each marker and approval weight calculation thereof please refer to ",(0,i.kt)("a",{parentName:"p",href:"/goshimmer/protocol_specification/components/consensus_mechanism#approval-weight-aw"},"Approval Weight"),"."),(0,i.kt)("h3",{id:"branch-mapping"},"Branch Mapping"),(0,i.kt)("p",null,"Branches are introduced to the Tangle when double spends occur and are carried forward (inherited) by messages until a conflict is resolved (merge to master). As such, each message needs to carry branch information and if a branch arises deep within the Tangle, each message would need to be traversed individually, which makes this operation very expensive and thus attackable."),(0,i.kt)("p",null,"Therefore, we utilize markers to store branch information for messages and store only a ",(0,i.kt)("strong",{parentName:"p"},"difference")," of branches (subtracted/added) on each message individually. In that way, propagation of branches can happen via structural marker information and not every message needs to be updated. When querying branch information of a message, first all branches of the message's past markers are retrieved and then combined with the diff of the message itself to result in the message's overall branch."))}h.isMDXComponent=!0},3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return h}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=p(a),h=r,d=u["".concat(l,".").concat(h)]||u[h]||c[h]||i;return a?n.createElement(d,s(s({ref:t},m),{},{components:a})):n.createElement(d,s({ref:t},m))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var p=2;p<i;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"}}]);